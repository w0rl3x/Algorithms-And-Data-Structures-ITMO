// Сдвинь меня, если сможешь
// Вам необходимо реализовать циклический сдвиг массива на K элементов без затрат на дополнительную память. Если K>0, то сдвиг происходит вправо (т. е последний элемент приходит в начало, а предпоследний оказывается последним), если же 
// K<0, то сдвиг происходит влево (т.е первый элемент уходит в конец, а второй оказывается первым).
// Сдвигом считается сдвиг элементов внутри массива, вывод элементов в нужном порядке приниматься не будет.
// Входные данные
// В первой строке даны два числа - N (1 ≤ N ≤ 10^3) и K (−10^9 ≤ K ≤ 10^9) - количество чисел и сдвиг.
// Во второй строке дано 
// N чисел, не превосходящие 10^9 и разделенные пробелом.

// Выходные данные
// Вывести последовательность чисел на K элементов


// оценка сложности - O(n)
#include <iostream>

// функция для реверса массива в заданном диапазоне
void razvorot(int a[], int left, int right) {
    for (int i = 0; i < (right - left) / 2; i++) { // идем по половине диапазона для избежания повторения операцмй
        // меняю местами элементы в начале и конце диапазона
        long t = a[i + left];
        a[i + left] = a[right - 1 - i];
        a[right - 1 - i] = t;
    }
}

int main()
{
    int n, k = 0; // размер массива и смещение
    std::cin >> n >> k;
    int a[n];
    for (int i = 0; i < n; i++) { // ввод элементов массива
        std::cin >> a[i];
    }

    k = (k % n + n) % n; // коррекция значения К к положительному значению

    // реверс массива три раза:
    razvorot(a, 0, n); // весь массив
    razvorot(a, 0, k); // первые k
    razvorot(a, k, n); // другие элементы

    for (int i = 0; i < n; i++) {
        std::cout << a[i] << " ";
    }
}